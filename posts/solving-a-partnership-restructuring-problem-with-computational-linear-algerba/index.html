<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Solving a partnership restructuring problem with linear algebra.</title><meta name=description content="The website of Daniel Furman"><meta name=author content="Daniel Furman"><link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2 crossorigin=anonymous><link rel=stylesheet href=/sass/researcher.min.css><link rel=icon type=image/ico href=https://daniel-furman.github.io/favicon.ico></head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})})</script><body><div class="container mt-5"><nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0"><a class="navbar-brand mx-0 mr-sm-auto" href=https://daniel-furman.github.io/>Daniel Furman</a><div class="navbar-nav flex-row flex-wrap justify-content-center"><a class="nav-item nav-link" href=/>About</a>
<span class="nav-item navbar-text mx-1">/</span>
<a class="nav-item nav-link" href=/posts>Posts</a>
<span class="nav-item navbar-text mx-1">/</span>
<a class="nav-item nav-link" href=/bookshelf>Bookshelf</a>
<span class="nav-item navbar-text mx-1">/</span>
<a class="nav-item nav-link" href=/resume>Resume</a>
<span class="nav-item navbar-text mx-1">/</span>
<a class="nav-item nav-link" href=/contact>Contact</a></div></nav></div><hr><div id=content><div class=container><h2 id=solving-a-partnership-restructuring-problem-with-linear-algebra>Solving a partnership restructuring problem with linear algebra</h2><hr><p>If youâ€™d like to skip straight to the code, jump ahead to the end.</p><p>Lets consider a partnership that is restructuring its assets (with N partners and M assets). The partners currently share the business, for example, partner N1 owns 33% of the company, partner N2 owns 20%, and so on. Each of the M assets carries a current value and a debt owed. Our task is to re-distribute the ownerships of the assets such that each is owned outright by one of the partners. Critically, we need to divvy the assets up without altering the partners' ownership shares. In effect, we want to split up the partnership in a fair manner, preserving each partner&rsquo;s stake in the business.</p><p>Linear algebra - to the rescue! First, create an NxM probability matrix encoding the ownership percentages (for example, partner N1 gets 100% of asset M1, 0% of asset M2, etc.). Multiply the NxM probability matrix with the Mx2 matrix encoding the assets' values and the debts. Subtract the result from the current ownership shares (a Nx2 matrix) (making sure that the entries match up to the correct partner). Take the absolute values and sum the entries, encoding the cumulative differences between the restructured ownership shares and the partners' original ownership shares. We then shuffle the columns up, re-run the pipeline, and record the new cumulative difference. Do this for all the different permutations of the column order and voila, find out whether or not your restructured partnership can get close to the original one.</p><p align=center><img src="https://render.githubusercontent.com/render/math?math=\begin{vmatrix} 1 & 1 & 0 & 0 & 0 & 0\\ 0 & 0 & 1 & 1 & 0 & 0\\ 0 & 0 & 0 & 0 & 1 & 1 \end{vmatrix} * begin{vmatrix} a & b \\ c & d \\ e & f \\ g & h \\ i & j \\k & l \end{vmatrix} - begin{vmatrix} m & n \\ o & p \\ q & r  \end{vmatrix}"></p><p><strong>Figure 1.</strong> A toy example of the linear algebra pipeline, it considers 6 assets shared among 3 partners. The first matrix encodes the probability matrix, where each partner is a row and each column is an asset. At each loop through the function we shuffle the columns, assigning the partners to a different set of assets. The second matrix encodes the current value (col1) and debt owed (col2) for the assets (rows). The third matrix encodes the three partners' original ownership value (col1) and debt owed (col2) for the assets (rows).</p><h3 id=how-good-can-this-search-algorithm-do>How good can this search algorithm do?</h3><p>And after all that, our result many turn out to be, well, pretty bad. Consider a simplified case: 2 partners own 3 assets shared evenly, but the assets are all equivalent, and, therefore, there is no way to split up the majority ownerships.</p><p>Another unattractive feature of our methodology was that we preemptively chose how many assets in total went to each partner, a step in the analytics pipeline that requires experimenting with. For example, in the matrix multiplications above, we decided that each partner got two properties. Some intuition must go into this initial decision after examining the original ownership stakes and the value/debts of the assets. This approach forces you to test all of the reasonable arrangements, which is only feasible for smaller order problems.</p><h3 id=when-does-this-approach-become-unwieldy>When does this approach become unwieldy?</h3><p>The approach is certainly a &ldquo;brute force&rdquo; method. The for loop through the permutations should theoretically be O(n) time complexity. However, the M! term mushrooms quickly, and your runtime can grow with large M accordingly, even though its a O(n) function. Lets confirm that runtime is linearly proportional:</p><img src="https://render.githubusercontent.com/render/math?math=\runtime \propto n"><p align=center><img src="assets-runtime.png?raw=true" / width=300 height=200></p><p><strong>Figure 2.</strong> Loglog plot of the runtime versus the number of M! loops through the function. The slope of the relationship is near 1, indicating that it is a linear power law, i.e., O(n) confirmed.</p><p>Thanks for reading about my business analytics problem. I am excited to write more about data science projects in the future. My blog can only grow from here!!</p><h2 id=appendix-code-implementation>Appendix: Code Implementation</h2><pre><code>### Libraries :
import numpy as np
from sympy.utilities.iterables import multiset_permutations

### Data I/O :
assets_value_debt = np.genfromtext(...) #asset value/debt df
restructure_probabilities = np.genfromtext(...) #initial state df
previous_stake = np.genfromtext(...) #previous asset value/debt df
num_assets = len(assets_value_debt[:,0]) #num of assets to restructure, n
n_factorial = np.math.factorial(num_assets) #num of scenarios, n!

### Search algorithm :
permutations = np.zeros((n_factorial, num_assets)) #initialize df
index = np.arange(0, num_assets) #index that stands for each asset
iter = 0
for p in multiset_permutations(index):
    permutations[iter,:] = p #sympy solves for all permutations
    iter+=1
permutations = permutations.astype(int) #make them ints (originally floats)

results = np.zeros(n_factorial) #initialize df
for iter in np.arange(0, n_factorial):
  # first grab the restructure state by reordering the features
  probabilities_looped = restructure_probabilities[:, permutations[iter,:]]
  # second solve the matrix multiplication step
  results_lopped = np.matmul(probabilities_looped, assets_value_debt)
  # lastly compute and sum the difference in before and after restructuring
  final_difference = np.abs(results_lopped - previous_stake)
  results[iter] = np.sum(final_difference)
np.min(results) #the minimum difference
np.argmin(results) #index of the best probability matrix
</code></pre></div></div><div id=footer class=mb-5><hr><div class="container text-center"><a href=https://daniel-furman.github.io/><small>By Daniel Furman</small></a></div></div></body></html>